% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/api.R
\name{diagnose_mfrm}
\alias{diagnose_mfrm}
\title{Compute diagnostics for an \code{mfrm_fit} object}
\usage{
diagnose_mfrm(
  fit,
  interaction_pairs = NULL,
  top_n_interactions = 20,
  whexact = FALSE,
  residual_pca = c("none", "overall", "facet", "both"),
  pca_max_factors = 10L
)
}
\arguments{
\item{fit}{Output from \code{\link[=fit_mfrm]{fit_mfrm()}}.}

\item{interaction_pairs}{Optional list of facet pairs.}

\item{top_n_interactions}{Number of top interactions.}

\item{whexact}{Use exact ZSTD transformation.}

\item{residual_pca}{Residual PCA mode: \code{"none"}, \code{"overall"}, \code{"facet"}, or \code{"both"}.}

\item{pca_max_factors}{Maximum number of PCA factors to retain per matrix.}
}
\value{
An object of class \code{mfrm_diagnostics} including:
\itemize{
\item \code{obs}: observed/expected/residual-level table
\item \code{measures}: facet/person fit table (\code{Infit}, \code{Outfit}, \code{ZSTD}, \code{PTMEA})
\item \code{overall_fit}: overall fit summary
\item \code{fit}: element-level fit diagnostics
\item \code{reliability}: separation/reliability by facet
\item \code{facets_chisq}: FACETS-style fixed/random facet chi-square summary
\item \code{interactions}: top interaction diagnostics
\item \code{interrater}: inter-rater agreement bundle (\code{summary}, \code{pairs})
\item \code{unexpected}: FACETS Table 4-style unexpected-response bundle
\item \code{fair_average}: FACETS Table 12-style fair-average bundle
\item \code{displacement}: displacement diagnostics bundle
\item \code{residual_pca_overall}: optional overall PCA object
\item \code{residual_pca_by_facet}: optional facet PCA objects
}
}
\description{
Compute diagnostics for an \code{mfrm_fit} object
}
\details{
This function computes a diagnostic bundle used by downstream reporting.

\code{interaction_pairs} controls which facet interactions are summarized.
Each element can be:
\itemize{
\item a length-2 character vector such as \code{c("Rater", "Criterion")}, or
\item omitted (\code{NULL}) to let the function select top interactions automatically.
}

Residual PCA behavior:
\itemize{
\item \code{"none"}: skip PCA
\item \code{"overall"}: compute only overall residual PCA
\item \code{"facet"}: compute only facet-specific residual PCA
\item \code{"both"}: compute both sets
}
}
\section{Reading key components}{

Practical interpretation often starts with:
\itemize{
\item \code{overall_fit}: global infit/outfit and degrees of freedom.
\item \code{reliability}: separation/reliability by facet (not a single pooled value).
\item \code{fit}: element-level misfit scan (\code{Infit}, \code{Outfit}, \code{ZSTD}).
\item \code{unexpected}, \code{fair_average}, \code{displacement}: targeted QC bundles.
}
}

\section{Interpreting output}{

Start with \code{overall_fit} and \code{reliability}, then move to element-level
diagnostics (\code{fit}) and targeted bundles (\code{unexpected}, \code{fair_average},
\code{displacement}, \code{interrater}, \code{facets_chisq}).

Consistent signals across multiple components are typically more robust than
a single isolated warning.
}

\section{Typical workflow}{

\enumerate{
\item Run \code{diagnose_mfrm(fit, residual_pca = "none")} for baseline diagnostics.
\item Inspect \code{summary(diag)} and targeted tables/plots.
\item If needed, rerun with residual PCA (\code{"overall"} or \code{"both"}).
}
}

\examples{
toy <- expand.grid(
  Person = paste0("P", 1:4),
  Rater = paste0("R", 1:2),
  Criterion = c("Content", "Organization", "Language"),
  stringsAsFactors = FALSE
)
toy$Score <- (
  as.integer(factor(toy$Person)) +
  2 * as.integer(factor(toy$Rater)) +
  as.integer(factor(toy$Criterion))
) \%\% 3
fit <- fit_mfrm(toy, "Person", c("Rater", "Criterion"), "Score", method = "JML", maxit = 25)
diag <- diagnose_mfrm(fit, residual_pca = "none")
s_diag <- summary(diag)
s_diag$overview[, c("Observations", "Facets", "Categories")]
p_qc <- plot_qc_dashboard(fit, diagnostics = diag, draw = FALSE)
class(p_qc)

# Optional: include residual PCA in the diagnostic bundle
diag_pca <- diagnose_mfrm(fit, residual_pca = "overall")
pca <- analyze_residual_pca(diag_pca, mode = "overall")
head(pca$overall_table)
}
\seealso{
\code{\link[=fit_mfrm]{fit_mfrm()}}, \code{\link[=analyze_residual_pca]{analyze_residual_pca()}}, \code{\link[=build_visual_summaries]{build_visual_summaries()}}
}
