% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/api.R
\name{facets_parity_report}
\alias{facets_parity_report}
\title{Build a FACETS parity report (column + metric contracts)}
\usage{
facets_parity_report(
  fit,
  diagnostics = NULL,
  bias_results = NULL,
  branch = c("facets", "original"),
  contract_file = NULL,
  include_metrics = TRUE,
  top_n_missing = 15L
)
}
\arguments{
\item{fit}{Output from \code{\link[=fit_mfrm]{fit_mfrm()}}.}

\item{diagnostics}{Optional output from \code{\link[=diagnose_mfrm]{diagnose_mfrm()}}. If omitted,
diagnostics are computed internally with \code{residual_pca = "none"}.}

\item{bias_results}{Optional output from \code{\link[=estimate_bias]{estimate_bias()}}. If omitted and
at least two facets exist, a 2-way bias run is computed internally.}

\item{branch}{Contract branch. \code{"facets"} checks FACETS-style columns.
\code{"original"} adapts branch-sensitive contracts (currently Table 11) to the
package's compact naming.}

\item{contract_file}{Optional path to a custom contract CSV.}

\item{include_metrics}{If \code{TRUE}, run additional numerical consistency checks.}

\item{top_n_missing}{Number of lowest-coverage contract rows to keep in
\code{missing_preview}.}
}
\value{
An object of class \code{mfrm_parity_report} with:
\itemize{
\item \code{overall}: one-row overall parity summary
\item \code{column_summary}: coverage summary by table ID
\item \code{column_audit}: row-level contract audit
\item \code{missing_preview}: lowest-coverage rows
\item \code{metric_summary}: one-row metric-check summary
\item \code{metric_by_table}: metric-check summary by table ID
\item \code{metric_audit}: row-level metric checks
\item \code{settings}: branch/contract metadata
}
}
\description{
Build a FACETS parity report (column + metric contracts)
}
\details{
This function compares produced report components to a contract specification
(\code{inst/references/facets_column_contract.csv}) and returns:
\itemize{
\item column-level coverage per contract row
\item table-level coverage summaries
\item optional metric-level consistency checks
}

Coverage interpretation in \code{overall}:
\itemize{
\item \code{MeanColumnCoverage} and \code{MinColumnCoverage} are computed across all
contract rows (unavailable rows count as 0 coverage).
\item \code{MeanColumnCoverageAvailable} and \code{MinColumnCoverageAvailable} summarize
only rows whose source component is available.
}

\code{summary(out)} is supported through \code{summary()}.
\code{plot(out)} is dispatched through \code{plot()} for class
\code{mfrm_parity_report} (\code{type = "column_coverage"}, \code{"table_coverage"},
\code{"metric_status"}, \code{"metric_by_table"}).
}
\section{Interpreting output}{

\itemize{
\item \code{overall}: high-level contract coverage and metric-check pass rates.
\item \code{column_summary} / \code{column_audit}: where schema mismatches occur.
\item \code{metric_summary} / \code{metric_audit}: numerical consistency checks.
\item \code{missing_preview}: quickest path to unresolved parity gaps.
}
}

\section{Typical workflow}{

\enumerate{
\item Run \code{facets_parity_report(fit, branch = "facets")}.
\item Inspect \code{summary(parity)} and \code{missing_preview}.
\item Patch upstream table builders, then rerun parity report.
}
}

\examples{
toy <- expand.grid(
  Person = paste0("P", 1:4),
  Rater = paste0("R", 1:2),
  Criterion = c("Content", "Organization", "Language"),
  stringsAsFactors = FALSE
)
toy$Score <- (
  as.integer(factor(toy$Person)) +
  2 * as.integer(factor(toy$Rater)) +
  as.integer(factor(toy$Criterion))
) \%\% 3
fit <- fit_mfrm(toy, "Person", c("Rater", "Criterion"), "Score", method = "JML", maxit = 25)
diag <- diagnose_mfrm(fit, residual_pca = "none")
parity <- facets_parity_report(fit, diagnostics = diag, branch = "facets")
summary(parity)
p <- plot(parity, draw = FALSE)
}
\seealso{
\code{\link[=fit_mfrm]{fit_mfrm()}}, \code{\link[=diagnose_mfrm]{diagnose_mfrm()}}, \code{\link[=build_fixed_reports]{build_fixed_reports()}}
}
